%Source for HW3, Winter 2012

\documentclass[11pt]{article}

\include{macros}
\newcommand{\bitsoracle}{{\mathsf{Bits}}}
\newcommand{\indcpa}{{\mathrm{IND}\mbox{-}\mathrm{CPA}}}
\newcommand{\indrcpa}{{\mathrm{IND}\$\mbox{-}\mathrm{CPA}}}
\newcommand{\rorcpa}{\mathrm{RoR}}
\newcommand{\Func}{\mathsf{Func}}

%\newcommand{\Adv}{\mathrm{Adv}}
\newcommand{\ExpUFCMA}[2]{\mathsf{Exp}^{\mathrm{ufcma}}_{#1}{(#2)}}
\newcommand{\ExpRoR}[2]{\mathsf{Exp}^{\mathrm{ror}}_{#1}{(#2)}}
\newcommand{\ExpPRF}[3]{\mathsf{Exp}^{\mathrm{prf}\mbox{-}#3}_{#1}{(#2)}}
\newcommand{\AdvPRF}[2]{\Adv^{\mathrm{prf}}_{#1}(#2)}
\newcommand{\AdvRoR}[2]{\Adv^{\mathrm{ror}}_{#1}(#2)}
\newcommand{\AdvUFCMA}[2]{\Adv^{\mathrm{ufcma}}_{#1}(#2)}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\title{\bf Problem Set 3 \\[2ex] 
       \rm\normalsize Modern Cryptography, Spring 2013}
\date{}
\author{}
\begin{document}
\maketitle


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\vspace*{-1in}

\begin{center}{Group: Binh Tran, David Baldwin\\}
\end{center}

\section*{Problem 1}
Let $E \colon \bits^n \times \bits^n \to \bits^n$ be a blockcipher,
and consider the following three functions, each mapping $\bits^n
\times \bits^n$ to $\bits^n$:

\begin{enumerate}
\item $f_1(V,M) = E_V(V \xor M) \xor M $\\

This function is not collision resistant. Consider the following attack that makes 1 query:\\
\begin{enumerate}
\item $V \gets 0^n$
\item $M_1 \getsr \bits^n$
\item $M_2 \getsr E^-1_V(M_1)$
\item return $(V, M_1)$ and $(V, M_2)$
\end{enumerate}

\textbf{Analysis}

\begin{eqnarray*}
f_1(V, M_1) = E_V(V \xor M_1) \xor M_1\\
=E_V(M_1) \xor M_1
\end{eqnarray*}

\item $f_2(V,M) = E_V(V \xor M) \xor V \xor M$

This function is collision-resistant because I say so and my words are infallible.\\
\item $f_3(V,M) = E_V(M) \xor V$
\\This function is also not collision resistant. Consider the following attack that makes 2 queries:\\
\begin{enumerate}
\item $V_1, V_2 \getsr \bits^n$ where $V_1 \neq V_2$\\
\item $M_1 \gets E^-1_{V_1}(V_1)$\\
\item $M_2 \gets E^-1_{V_2}(V_2)$\\
\end{enumerate}

\textbf{Analysis}
\begin{eqnarray*}
E_{V_1}(M_1) \xor V_1 &=& E_{V_1}(E^-1_{V_1}(V_1)) \xor V_1 \\
&=& V_1 \xor V_1 \\
&=& 0^n\\
\end{eqnarray*}
and
\begin{eqnarray*}
E_{V_2}(M_2) \xor V_2 &=& E_{V_2}(E^-1_{V_2}(V_2)) \xor V_2 \\
&=& V_2 \xor V_2 \\
&=& 0^n\\
\end{eqnarray*}
This causes the collision\\
\end{enumerate}


We know that for functions such as $f(V,M) = E_V(M)$ it is possible to find a collision for any two distinct key pairs $V_1$ and $V_2$ and a message $M_1$ by computing $M_2 = E^{-1}_{V_2}(E_{V_1}(M_1))$.  Both pairs then encrypt to $E_V1(M_1)$.  It is also true that functions in the form (a) $f(V,M) = E_V(M) \xor M$ are secure.  Intuitively, this is because it is diffcult to mount the same attack, because the value of $M$ appears both within the encryption function as well as outside of it.

It is not easy to utilize the key variable to eliminate this outer term, anything in the form (b) $f(E^{-1}_{k_1}(.),M)$ will lead to an decryption that is useless for finding collisions, i.e., $E_{E^{-1}_{k_1}(z)}( E^{-1}_{k_1}(z) )$ 

To effectively find collisions in this situation, it is sufficient to find $E_V(M) = M$ but doing so requires one to exhaustively search the keyspace, which may yield similar complexity to a birthday attack.

The function 

\[
f_1(V,M) = E_V(V \xor M) \xor M 
\]

is no more susceptible to an attack than the form (a). Such an attack would require $E_V(V \xor M) \xor M$ to be easier to find collisons than $E_V(M) \xor M$.  But $V \xor M$ is a linear transform over a function that maps its inputs arbitarily, so it should be no weaker.

For the same reasons
\[
f_2(V,M) = E_V(V \xor M) \xor M \xor V
\]
should be collision resistant as well.  We need $E_V(V \xor M)$ to map ot the same value for two inputs. Any application of a the function with M as an decryption  also appears outside the function.  If V is also the same value, wee may be able to find a clission, but this suffers from the same issue as seen in form (b) above.

For the function 

\[
f_3(V,M) = E_V(M) \xor V
\]

We can create a collision over all values of $V$ by computing 

\[
f_3(V,D^{-1}_V(V)) = V \xor V = 0
\]

Imagine that you are an attacker, and you would like to exhibit
collisions in these functions.  Specifically, for each~$i=1,2,3$, you need
to find two pairs of inputs  $(V,M) \neq (V',M')$ such that
$f_i(V,M) = f_i(V',M')$.  

Your attacks are mounted in the ideal cipher
model for~$E$, so assume that you are given oracles for
$E(\cdot,\cdot)$ and $E^{-1}(\cdot,\cdot)$.  To the former oracle, you
may ask $(K,X)$ and receive $Y \gets E_K(X)$ in return; to the latter oracle,
you may ask $(K,Y)$ and receive $X \gets E^{-1}_K(Y)$ in return.  Your
attacks should be as efficient as possible, i.e.\ ask as few oracle
queries as you can.

If you find that one or more of $f_1,f_2,f_3$ is does not yield
collisions in a reasonable number of queries, you might take off your
``attacker hat'' and put on your ``prover hat'', to see if you can
argue that query-efficient attacks are unlikely to exist.  (Ask
yourself: what is the maximum number of queries that you can hope to
force an attacker to make for a $2n$-bit to $n$-bit mapping?)

\newcommand{\oPi}{\overline{\Pi}}
\newcommand{\ocalK}{\overline{\mathcal{K}}}
\newcommand{\ocalE}{\overline{\mathcal{E}}}
\newcommand{\ocalD}{\overline{\mathcal{D}}}

\vspace*{-.25in}
\section*{Problem 2} Let~$F \colon \bits^k \times \bits^* \to \bits^n$
be a function family, and let $\Pi = (\calK,\calE,\calD)$ be an
encryption scheme.  Consider the following encryption scheme $\oPi =
(\ocalK,\ocalE,\ocalD)$ where 
\[
\ocalE_{K1,K2}(M) = \calE_{K1}(M)\concat F_{K2}(K1 \concat M)\, .
\]  
To decrypt, $\ocalD_{K1,K2}(C)$
operates as follows: (1) parse~$C$ into $Y \concat T$ where $|T|=n$; (2) $X
\gets \calD_{K1}(Y)$, and if~$X = \bot$ then return~$\bot$; (3) if
$F_{K2}(K1 \concat X)=T$ then return~$X$, else return $\bot$.

\paragraph{Part 1.} Assume that~$F$ is a good PRF, and that $\Pi$ is IND\$-CPA secure.
Are these assumptions sufficient to prove that $\oPi$ is IND\$-CPA
secure?

\newcommand{\INDR}{IND\$-CPA}
\newcommand{\ExpINDz}[2]{\mathsf{Exp}^{\mathrm{ind}\mbox{-}\mathrm{cpa0}}_{#1}{(#2)}}
\newcommand{\ExpINDo}[2]{\mathsf{Exp}^{\mathrm{ind}\mbox{-}\mathrm{cpa1}}_{#1}{(#2)}}
\newcommand{\ExpINDR}[2]{\mathsf{Exp}^{\mathrm{ind\$}\mbox{-}\mathrm{cpa}}_{#1}{(#2)}}
\newcommand{\AdvINDR}[2]{\Adv^{\mathrm{ind\$}\mbox{-}\mathrm{cpa}}_{#1}(#2)}

\textsc{Answer} 
\\$\oPi$ is not \INDR. Here's an adversary A for $\ExpINDR{\oPi}{(A)}$ that makes 2 query totaling $2n$ bits length, $O(1)$ calculation time:
\begin{enumerate}
\item M $\getsr \bits^n$
\item $X_l \concat X_r \gets X \gets \calO(M)$ where $|X_r| = n$
\item $Y_l \concat Y_r \gets Y \gets \calO(M)$ where $|Y_r| = n$
\item if $X_r = Y_r$ then \texttt{ return 1} else \texttt{ return 0}
\end{enumerate}

\textsc{Analysis}\\
\begin{enumerate}
\item In $\ExpINDo{\oPi}{A}$\\
$X_r = F_{K2}(K1 \concat M)$ and $Y_r = F_{K2}(K1 \concat M)$ by the construction of $\oPi$ thus\\
\begin{center}
 $Pr(\ExpINDo{\oPi}{A}=1) =1$
\end{center}

\item In $\ExpINDz{\oPi}{A}$\\
If $\calO (M)$ is random then A returns 1 when 2 random bit strings has the same suffix 

\begin{eqnarray*}
Pr(\ExpINDo{\oPi}{A}=1) &=& Pr (X_r = Y_r)\\
&=& Pr (X_r = T: Y_r = T)\\
&=& \frac{1}{2^n}
\end{eqnarray*}

\item $\AdvINDR{\oPi}{A}$\\

\begin{eqnarray*}
\AdvINDR{\oPi}{A} &=& Pr(\ExpINDo{\oPi}{A}=1)-Pr(\ExpINDz{\oPi}{A}=1)\\
&=& 1 - \frac{1}{2^n}
\end{eqnarray*}

\end{enumerate}

\paragraph{Part 2.} Are these assumptions sufficient to prove that $\oPi$ is AUTH-secure?
If so, please give a detailed proof sketch (as above), and what you
expect will be the security bound.  If not, please give an efficient attack.

\textsc{Answer}\\



\end{document}
